
import time
import logging
# import subprocess 
#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

import grpc  # type: ignore

import client_pb2 as client_pb2  # type: ignore
import client_pb2_grpc as client_pb2_grpc  # type: ignore

KEYGROUP = "simple"


# with open("cert.crt") as f:
# crt = f.read().encode()

# creds = grpc.ssl_channel_credentials(ca, key, crt)

logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s")





# gateway = get_gateway_ip() 
# print(f"Gateway IP: {gateway}") 


MOCK_FRED_ADDRESS = 'localhost:9001'
logging.info(f"get_fn: Connecting to MockFReD at {MOCK_FRED_ADDRESS}")

channel = grpc.insecure_channel(MOCK_FRED_ADDRESS)
stub = client_pb2_grpc.ClientStub(channel)


def get(key: str) -> str:
    rr = client_pb2.ReadRequest(
        keygroup=KEYGROUP,
        id=key,
    )
    logging.debug(f"get_fn: Sending ReadRequest for key: {key}")
    try:
        response = stub.Read(rr)
        if response and response.data:
           
            value = response.data[0].val
            logging.debug(f"get_fn: Received value '{value}' for key '{key}'")
            return value
        else:
            logging.warning(f"get_fn: No data found for key '{key}' in response.")
            
            return "" 
    except grpc.RpcError as e:
        logging.error(f"get_fn: gRPC error getting value for key '{key}': {e.code()} - {e.details()}")
        
        raise 


def fn(inp: str) -> str: 
    # input is just a key
    t1 = time.perf_counter()
    logging.info(f"get_fn (FaaS entry): Received request to get key '{inp}'")

    val = "" 
    try:
        val = get(inp)
    except Exception as e: 
        logging.error(f"get_fn (FaaS entry): Error getting value for key '{inp}': {e}")
        
        raise 

    logging.info(f"get_fn (FaaS entry): Time taken: {time.perf_counter() - t1:.4f}s. Returning value for '{inp}'.")
    return val


if __name__ == '__main__':
    logging.getLogger().setLevel(logging.INFO) 

    

    print("Testing get_fn locally...")
    try:
        

        retrieved_value_nonexistent = fn("nonexistentkey")
        print(f"Attempted to retrieve value for 'nonexistentkey': {retrieved_value_nonexistent} (expected error or empty)")

    except Exception as e:
        print(f"Error during local test of get_fn: {e}")
